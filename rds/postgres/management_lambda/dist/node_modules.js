'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var events = _interopDefault(require('events'));
var util = _interopDefault(require('util'));
var crypto = _interopDefault(require('crypto'));
var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs'));
var stream = _interopDefault(require('stream'));
var string_decoder = _interopDefault(require('string_decoder'));
var dns = _interopDefault(require('dns'));
var url = _interopDefault(require('url'));
var net = _interopDefault(require('net'));
var assert = _interopDefault(require('assert'));
var tls = _interopDefault(require('tls'));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var parse = function (source, transform) {
  return new ArrayParser(source, transform).parse()
};

class ArrayParser {
  constructor (source, transform) {
    this.source = source;
    this.transform = transform || identity;
    this.position = 0;
    this.entries = [];
    this.recorded = [];
    this.dimension = 0;
  }

  isEof () {
    return this.position >= this.source.length
  }

  nextCharacter () {
    var character = this.source[this.position++];
    if (character === '\\') {
      return {
        value: this.source[this.position++],
        escaped: true
      }
    }
    return {
      value: character,
      escaped: false
    }
  }

  record (character) {
    this.recorded.push(character);
  }

  newEntry (includeEmpty) {
    var entry;
    if (this.recorded.length > 0 || includeEmpty) {
      entry = this.recorded.join('');
      if (entry === 'NULL' && !includeEmpty) {
        entry = null;
      }
      if (entry !== null) entry = this.transform(entry);
      this.entries.push(entry);
      this.recorded = [];
    }
  }

  consumeDimensions () {
    if (this.source[0] === '[') {
      while (!this.isEof()) {
        var char = this.nextCharacter();
        if (char.value === '=') break
      }
    }
  }

  parse (nested) {
    var character, parser, quote;
    this.consumeDimensions();
    while (!this.isEof()) {
      character = this.nextCharacter();
      if (character.value === '{' && !quote) {
        this.dimension++;
        if (this.dimension > 1) {
          parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
          this.entries.push(parser.parse(true));
          this.position += parser.position - 2;
        }
      } else if (character.value === '}' && !quote) {
        this.dimension--;
        if (!this.dimension) {
          this.newEntry();
          if (nested) return this.entries
        }
      } else if (character.value === '"' && !character.escaped) {
        if (quote) this.newEntry(true);
        quote = !quote;
      } else if (character.value === ',' && !quote) {
        this.newEntry();
      } else {
        this.record(character.value);
      }
    }
    if (this.dimension !== 0) {
      throw new Error('array dimension not balanced')
    }
    return this.entries
  }
}

function identity (value) {
  return value
}

var postgresArray = {
	parse: parse
};

var arrayParser = {
  create: function (source, transform) {
    return {
      parse: function() {
        return postgresArray.parse(source, transform);
      }
    };
  }
};

var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
var INFINITY = /^-?infinity$/;

var postgresDate = function parseDate (isoDate) {
  if (INFINITY.test(isoDate)) {
    // Capitalize to Infinity before passing to Number
    return Number(isoDate.replace('i', 'I'))
  }
  var matches = DATE_TIME.exec(isoDate);

  if (!matches) {
    // Force YYYY-MM-DD dates to be parsed as local time
    return getDate(isoDate) || null
  }

  var isBC = !!matches[8];
  var year = parseInt(matches[1], 10);
  if (isBC) {
    year = bcYearToNegativeYear(year);
  }

  var month = parseInt(matches[2], 10) - 1;
  var day = matches[3];
  var hour = parseInt(matches[4], 10);
  var minute = parseInt(matches[5], 10);
  var second = parseInt(matches[6], 10);

  var ms = matches[7];
  ms = ms ? 1000 * parseFloat(ms) : 0;

  var date;
  var offset = timeZoneOffset(isoDate);
  if (offset != null) {
    date = new Date(Date.UTC(year, month, day, hour, minute, second, ms));

    // Account for years from 0 to 99 being interpreted as 1900-1999
    // by Date.UTC / the multi-argument form of the Date constructor
    if (is0To99(year)) {
      date.setUTCFullYear(year);
    }

    date.setTime(date.getTime() - offset);
  } else {
    date = new Date(year, month, day, hour, minute, second, ms);

    if (is0To99(year)) {
      date.setFullYear(year);
    }
  }

  return date
};

function getDate (isoDate) {
  var matches = DATE.exec(isoDate);
  if (!matches) {
    return
  }

  var year = parseInt(matches[1], 10);
  var isBC = !!matches[4];
  if (isBC) {
    year = bcYearToNegativeYear(year);
  }

  var month = parseInt(matches[2], 10) - 1;
  var day = matches[3];
  // YYYY-MM-DD will be parsed as local time
  var date = new Date(year, month, day);

  if (is0To99(year)) {
    date.setFullYear(year);
  }

  return date
}

// match timezones:
// Z (UTC)
// -05
// +06:30
function timeZoneOffset (isoDate) {
  var zone = TIME_ZONE.exec(isoDate.split(' ')[1]);
  if (!zone) return
  var type = zone[1];

  if (type === 'Z') {
    return 0
  }
  var sign = type === '-' ? -1 : 1;
  var offset = parseInt(zone[2], 10) * 3600 +
    parseInt(zone[3] || 0, 10) * 60 +
    parseInt(zone[4] || 0, 10);

  return offset * sign * 1000
}

function bcYearToNegativeYear (year) {
  // Account for numerical difference between representations of BC years
  // See: https://github.com/bendrucker/postgres-date/issues/5
  return -(year - 1)
}

function is0To99 (num) {
  return num >= 0 && num < 100
}

var mutable = extend;

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target
}

var postgresInterval = PostgresInterval;

function PostgresInterval (raw) {
  if (!(this instanceof PostgresInterval)) {
    return new PostgresInterval(raw)
  }
  mutable(this, parse$1(raw));
}
var properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years'];
PostgresInterval.prototype.toPostgres = function () {
  var filtered = properties.filter(this.hasOwnProperty, this);

  // In addition to `properties`, we need to account for fractions of seconds.
  if (this.milliseconds && filtered.indexOf('seconds') < 0) {
    filtered.push('seconds');
  }

  if (filtered.length === 0) return '0'
  return filtered
    .map(function (property) {
      var value = this[property] || 0;

      // Account for fractional part of seconds,
      // remove trailing zeroes.
      if (property === 'seconds' && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, '');
      }

      return value + ' ' + property
    }, this)
    .join(' ')
};

var propertiesISOEquivalent = {
  years: 'Y',
  months: 'M',
  days: 'D',
  hours: 'H',
  minutes: 'M',
  seconds: 'S'
};
var dateProperties = ['years', 'months', 'days'];
var timeProperties = ['hours', 'minutes', 'seconds'];
// according to ISO 8601
PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function () {
  var datePart = dateProperties
    .map(buildProperty, this)
    .join('');

  var timePart = timeProperties
    .map(buildProperty, this)
    .join('');

  return 'P' + datePart + 'T' + timePart

  function buildProperty (property) {
    var value = this[property] || 0;

    // Account for fractional part of seconds,
    // remove trailing zeroes.
    if (property === 'seconds' && this.milliseconds) {
      value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, '');
    }

    return value + propertiesISOEquivalent[property]
  }
};

var NUMBER = '([+-]?\\d+)';
var YEAR = NUMBER + '\\s+years?';
var MONTH = NUMBER + '\\s+mons?';
var DAY = NUMBER + '\\s+days?';
var TIME = '([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?';
var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function (regexString) {
  return '(' + regexString + ')?'
})
  .join('\\s*'));

// Positions of values in regex match
var positions = {
  years: 2,
  months: 4,
  days: 6,
  hours: 9,
  minutes: 10,
  seconds: 11,
  milliseconds: 12
};
// We can use negative time
var negatives = ['hours', 'minutes', 'seconds', 'milliseconds'];

function parseMilliseconds (fraction) {
  // add omitted zeroes
  var microseconds = fraction + '000000'.slice(fraction.length);
  return parseInt(microseconds, 10) / 1000
}

function parse$1 (interval) {
  if (!interval) return {}
  var matches = INTERVAL.exec(interval);
  var isNegative = matches[8] === '-';
  return Object.keys(positions)
    .reduce(function (parsed, property) {
      var position = positions[property];
      var value = matches[position];
      // no empty string
      if (!value) return parsed
      // milliseconds are actually microseconds (up to 6 digits)
      // with omitted trailing zeroes.
      value = property === 'milliseconds'
        ? parseMilliseconds(value)
        : parseInt(value, 10);
      // no zeros
      if (!value) return parsed
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed
    }, {})
}

var postgresBytea = function parseBytea (input) {
  if (/^\\x/.test(input)) {
    // new 'hex' style response (pg >9.0)
    return new Buffer(input.substr(2), 'hex')
  }
  var output = '';
  var i = 0;
  while (i < input.length) {
    if (input[i] !== '\\') {
      output += input[i];
      ++i;
    } else {
      if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
        output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
        i += 4;
      } else {
        var backslashes = 1;
        while (i + backslashes < input.length && input[i + backslashes] === '\\') {
          backslashes++;
        }
        for (var k = 0; k < Math.floor(backslashes / 2); ++k) {
          output += '\\';
        }
        i += Math.floor(backslashes / 2) * 2;
      }
    }
  }
  return new Buffer(output, 'binary')
};

function allowNull (fn) {
  return function nullAllowed (value) {
    if (value === null) return value
    return fn(value)
  }
}

function parseBool (value) {
  if (value === null) return value
  return value === 'TRUE' ||
    value === 't' ||
    value === 'true' ||
    value === 'y' ||
    value === 'yes' ||
    value === 'on' ||
    value === '1';
}

function parseBoolArray (value) {
  if (!value) return null
  return postgresArray.parse(value, parseBool)
}

function parseBaseTenInt (string) {
  return parseInt(string, 10)
}

function parseIntegerArray (value) {
  if (!value) return null
  return postgresArray.parse(value, allowNull(parseBaseTenInt))
}

function parseBigIntegerArray (value) {
  if (!value) return null
  return postgresArray.parse(value, allowNull(function (entry) {
    return parseBigInteger(entry).trim()
  }))
}

var parsePointArray = function(value) {
  if(!value) { return null; }
  var p = arrayParser.create(value, function(entry) {
    if(entry !== null) {
      entry = parsePoint(entry);
    }
    return entry;
  });

  return p.parse();
};

var parseFloatArray = function(value) {
  if(!value) { return null; }
  var p = arrayParser.create(value, function(entry) {
    if(entry !== null) {
      entry = parseFloat(entry);
    }
    return entry;
  });

  return p.parse();
};

var parseStringArray = function(value) {
  if(!value) { return null; }

  var p = arrayParser.create(value);
  return p.parse();
};

var parseDateArray = function(value) {
  if (!value) { return null; }

  var p = arrayParser.create(value, function(entry) {
    if (entry !== null) {
      entry = postgresDate(entry);
    }
    return entry;
  });

  return p.parse();
};

var parseIntervalArray = function(value) {
  if (!value) { return null; }

  var p = arrayParser.create(value, function(entry) {
    if (entry !== null) {
      entry = postgresInterval(entry);
    }
    return entry;
  });

  return p.parse();
};

var parseByteAArray = function(value) {
  if (!value) { return null; }

  return postgresArray.parse(value, allowNull(postgresBytea));
};

var parseInteger = function(value) {
  return parseInt(value, 10);
};

var parseBigInteger = function(value) {
  var valStr = String(value);
  if (/^\d+$/.test(valStr)) { return valStr; }
  return value;
};

var parseJsonArray = function(value) {
  if (!value) { return null; }

  return postgresArray.parse(value, allowNull(JSON.parse));
};

var parsePoint = function(value) {
  if (value[0] !== '(') { return null; }

  value = value.substring( 1, value.length - 1 ).split(',');

  return {
    x: parseFloat(value[0])
  , y: parseFloat(value[1])
  };
};

var parseCircle = function(value) {
  if (value[0] !== '<' && value[1] !== '(') { return null; }

  var point = '(';
  var radius = '';
  var pointParsed = false;
  for (var i = 2; i < value.length - 1; i++){
    if (!pointParsed) {
      point += value[i];
    }

    if (value[i] === ')') {
      pointParsed = true;
      continue;
    } else if (!pointParsed) {
      continue;
    }

    if (value[i] === ','){
      continue;
    }

    radius += value[i];
  }
  var result = parsePoint(point);
  result.radius = parseFloat(radius);

  return result;
};

var init = function(register) {
  register(20, parseBigInteger); // int8
  register(21, parseInteger); // int2
  register(23, parseInteger); // int4
  register(26, parseInteger); // oid
  register(700, parseFloat); // float4/real
  register(701, parseFloat); // float8/double
  register(16, parseBool);
  register(1082, postgresDate); // date
  register(1114, postgresDate); // timestamp without timezone
  register(1184, postgresDate); // timestamp
  register(600, parsePoint); // point
  register(651, parseStringArray); // cidr[]
  register(718, parseCircle); // circle
  register(1000, parseBoolArray);
  register(1001, parseByteAArray);
  register(1005, parseIntegerArray); // _int2
  register(1007, parseIntegerArray); // _int4
  register(1028, parseIntegerArray); // oid[]
  register(1016, parseBigIntegerArray); // _int8
  register(1017, parsePointArray); // point[]
  register(1021, parseFloatArray); // _float4
  register(1022, parseFloatArray); // _float8
  register(1231, parseFloatArray); // _numeric
  register(1014, parseStringArray); //char
  register(1015, parseStringArray); //varchar
  register(1008, parseStringArray);
  register(1009, parseStringArray);
  register(1040, parseStringArray); // macaddr[]
  register(1041, parseStringArray); // inet[]
  register(1115, parseDateArray); // timestamp without time zone[]
  register(1182, parseDateArray); // _date
  register(1185, parseDateArray); // timestamp with time zone[]
  register(1186, postgresInterval);
  register(1187, parseIntervalArray);
  register(17, postgresBytea);
  register(114, JSON.parse.bind(JSON)); // json
  register(3802, JSON.parse.bind(JSON)); // jsonb
  register(199, parseJsonArray); // json[]
  register(3807, parseJsonArray); // jsonb[]
  register(3907, parseStringArray); // numrange[]
  register(2951, parseStringArray); // uuid[]
  register(791, parseStringArray); // money[]
  register(1183, parseStringArray); // time[]
  register(1270, parseStringArray); // timetz[]
};

var textParsers = {
  init: init
};

// selected so (BASE - 1) * 0x100000000 + 0xffffffff is a safe integer
var BASE = 1000000;

function readInt8(buffer) {
	var high = buffer.readInt32BE(0);
	var low = buffer.readUInt32BE(4);
	var sign = '';

	if (high < 0) {
		high = ~high + (low === 0);
		low = (~low + 1) >>> 0;
		sign = '-';
	}

	var result = '';
	var carry;
	var t;
	var digits;
	var pad;
	var l;
	var i;

	{
		carry = high % BASE;
		high = high / BASE >>> 0;

		t = 0x100000000 * carry + low;
		low = t / BASE >>> 0;
		digits = '' + (t - BASE * low);

		if (low === 0 && high === 0) {
			return sign + digits + result;
		}

		pad = '';
		l = 6 - digits.length;

		for (i = 0; i < l; i++) {
			pad += '0';
		}

		result = pad + digits + result;
	}

	{
		carry = high % BASE;
		high = high / BASE >>> 0;

		t = 0x100000000 * carry + low;
		low = t / BASE >>> 0;
		digits = '' + (t - BASE * low);

		if (low === 0 && high === 0) {
			return sign + digits + result;
		}

		pad = '';
		l = 6 - digits.length;

		for (i = 0; i < l; i++) {
			pad += '0';
		}

		result = pad + digits + result;
	}

	{
		carry = high % BASE;
		high = high / BASE >>> 0;

		t = 0x100000000 * carry + low;
		low = t / BASE >>> 0;
		digits = '' + (t - BASE * low);

		if (low === 0 && high === 0) {
			return sign + digits + result;
		}

		pad = '';
		l = 6 - digits.length;

		for (i = 0; i < l; i++) {
			pad += '0';
		}

		result = pad + digits + result;
	}

	{
		carry = high % BASE;
		t = 0x100000000 * carry + low;
		digits = '' + t % BASE;

		return sign + digits + result;
	}
}

var pgInt8 = readInt8;

var parseBits = function(data, bits, offset, invert, callback) {
  offset = offset || 0;
  invert = invert || false;
  callback = callback || function(lastValue, newValue, bits) { return (lastValue * Math.pow(2, bits)) + newValue; };
  var offsetBytes = offset >> 3;

  var inv = function(value) {
    if (invert) {
      return ~value & 0xff;
    }

    return value;
  };

  // read first (maybe partial) byte
  var mask = 0xff;
  var firstBits = 8 - (offset % 8);
  if (bits < firstBits) {
    mask = (0xff << (8 - bits)) & 0xff;
    firstBits = bits;
  }

  if (offset) {
    mask = mask >> (offset % 8);
  }

  var result = 0;
  if ((offset % 8) + bits >= 8) {
    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
  }

  // read bytes
  var bytes = (bits + offset) >> 3;
  for (var i = offsetBytes + 1; i < bytes; i++) {
    result = callback(result, inv(data[i]), 8);
  }

  // bits to read, that are not a complete byte
  var lastBits = (bits + offset) % 8;
  if (lastBits > 0) {
    result = callback(result, inv(data[bytes]) >> (8 - lastBits), lastBits);
  }

  return result;
};

var parseFloatFromBits = function(data, precisionBits, exponentBits) {
  var bias = Math.pow(2, exponentBits - 1) - 1;
  var sign = parseBits(data, 1);
  var exponent = parseBits(data, exponentBits, 1);

  if (exponent === 0) {
    return 0;
  }

  // parse mantissa
  var precisionBitsCounter = 1;
  var parsePrecisionBits = function(lastValue, newValue, bits) {
    if (lastValue === 0) {
      lastValue = 1;
    }

    for (var i = 1; i <= bits; i++) {
      precisionBitsCounter /= 2;
      if ((newValue & (0x1 << (bits - i))) > 0) {
        lastValue += precisionBitsCounter;
      }
    }

    return lastValue;
  };

  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);

  // special cases
  if (exponent == (Math.pow(2, exponentBits + 1) - 1)) {
    if (mantissa === 0) {
      return (sign === 0) ? Infinity : -Infinity;
    }

    return NaN;
  }

  // normale number
  return ((sign === 0) ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
};

var parseInt16 = function(value) {
  if (parseBits(value, 1) == 1) {
    return -1 * (parseBits(value, 15, 1, true) + 1);
  }

  return parseBits(value, 15, 1);
};

var parseInt32 = function(value) {
  if (parseBits(value, 1) == 1) {
    return -1 * (parseBits(value, 31, 1, true) + 1);
  }

  return parseBits(value, 31, 1);
};

var parseFloat32 = function(value) {
  return parseFloatFromBits(value, 23, 8);
};

var parseFloat64 = function(value) {
  return parseFloatFromBits(value, 52, 11);
};

var parseNumeric = function(value) {
  var sign = parseBits(value, 16, 32);
  if (sign == 0xc000) {
    return NaN;
  }

  var weight = Math.pow(10000, parseBits(value, 16, 16));
  var result = 0;
  var ndigits = parseBits(value, 16);
  for (var i = 0; i < ndigits; i++) {
    result += parseBits(value, 16, 64 + (16 * i)) * weight;
    weight /= 10000;
  }

  var scale = Math.pow(10, parseBits(value, 16, 48));
  return ((sign === 0) ? 1 : -1) * Math.round(result * scale) / scale;
};

var parseDate = function(isUTC, value) {
  var sign = parseBits(value, 1);
  var rawValue = parseBits(value, 63, 1);

  // discard usecs and shift from 2000 to 1970
  var result = new Date((((sign === 0) ? 1 : -1) * rawValue / 1000) + 946684800000);

  if (!isUTC) {
    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
  }

  // add microseconds to the date
  result.usec = rawValue % 1000;
  result.getMicroSeconds = function() {
    return this.usec;
  };
  result.setMicroSeconds = function(value) {
    this.usec = value;
  };
  result.getUTCMicroSeconds = function() {
    return this.usec;
  };

  return result;
};

var parseArray = function(value) {
  var dim = parseBits(value, 32);

  var flags = parseBits(value, 32, 32);
  var elementType = parseBits(value, 32, 64);

  var offset = 96;
  var dims = [];
  for (var i = 0; i < dim; i++) {
    // parse dimension
    dims[i] = parseBits(value, 32, offset);
    offset += 32;

    // ignore lower bounds
    offset += 32;
  }

  var parseElement = function(elementType) {
    // parse content length
    var length = parseBits(value, 32, offset);
    offset += 32;

    // parse null values
    if (length == 0xffffffff) {
      return null;
    }

    var result;
    if ((elementType == 0x17) || (elementType == 0x14)) {
      // int/bigint
      result = parseBits(value, length * 8, offset);
      offset += length * 8;
      return result;
    }
    else if (elementType == 0x19) {
      // string
      result = value.toString(this.encoding, offset >> 3, (offset += (length << 3)) >> 3);
      return result;
    }
    else {
      console.log("ERROR: ElementType not implemented: " + elementType);
    }
  };

  var parse = function(dimension, elementType) {
    var array = [];
    var i;

    if (dimension.length > 1) {
      var count = dimension.shift();
      for (i = 0; i < count; i++) {
        array[i] = parse(dimension, elementType);
      }
      dimension.unshift(count);
    }
    else {
      for (i = 0; i < dimension[0]; i++) {
        array[i] = parseElement(elementType);
      }
    }

    return array;
  };

  return parse(dims, elementType);
};

var parseText = function(value) {
  return value.toString('utf8');
};

var parseBool$1 = function(value) {
  if(value === null) return null;
  return (parseBits(value, 8) > 0);
};

var init$1 = function(register) {
  register(20, pgInt8);
  register(21, parseInt16);
  register(23, parseInt32);
  register(26, parseInt32);
  register(1700, parseNumeric);
  register(700, parseFloat32);
  register(701, parseFloat64);
  register(16, parseBool$1);
  register(1114, parseDate.bind(null, false));
  register(1184, parseDate.bind(null, true));
  register(1000, parseArray);
  register(1007, parseArray);
  register(1016, parseArray);
  register(1008, parseArray);
  register(1009, parseArray);
  register(25, parseText);
};

var binaryParsers = {
  init: init$1
};

/**
 * Following query was used to generate this file:

 SELECT json_object_agg(UPPER(PT.typname), PT.oid::int4 ORDER BY pt.oid)
 FROM pg_type PT
 WHERE typnamespace = (SELECT pgn.oid FROM pg_namespace pgn WHERE nspname = 'pg_catalog') -- Take only builting Postgres types with stable OID (extension types are not guaranted to be stable)
 AND typtype = 'b' -- Only basic types
 AND typelem = 0 -- Ignore aliases
 AND typisdefined -- Ignore undefined types
 */

var builtins = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
};

var getTypeParser_1 = getTypeParser;
var setTypeParser_1 = setTypeParser;
var arrayParser_1 = arrayParser;
var builtins$1 = builtins;

var typeParsers = {
  text: {},
  binary: {}
};

//the empty parse function
function noParse (val) {
  return String(val);
}
//returns a function used to convert a specific type (specified by
//oid) into a result javascript type
//note: the oid can be obtained via the following sql query:
//SELECT oid FROM pg_type WHERE typname = 'TYPE_NAME_HERE';
function getTypeParser (oid, format) {
  format = format || 'text';
  if (!typeParsers[format]) {
    return noParse;
  }
  return typeParsers[format][oid] || noParse;
}
function setTypeParser (oid, format, parseFn) {
  if(typeof format == 'function') {
    parseFn = format;
    format = 'text';
  }
  typeParsers[format][oid] = parseFn;
}
textParsers.init(function(oid, converter) {
  typeParsers.text[oid] = converter;
});

binaryParsers.init(function(oid, converter) {
  typeParsers.binary[oid] = converter;
});

var pgTypes = {
	getTypeParser: getTypeParser_1,
	setTypeParser: setTypeParser_1,
	arrayParser: arrayParser_1,
	builtins: builtins$1
};

var defaults = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * README.md file in the root directory of this source tree.
 */

module.exports = {
  // database host. defaults to localhost
  host: 'localhost',

  // database user's name
  user: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,

  // name of database to connect
  database: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,

  // database user's password
  password: null,

  // a Postgres connection string to be used instead of setting individual connection items
  // NOTE:  Setting this value will cause it to override any other value (such as database or user) defined
  // in the defaults object.
  connectionString: undefined,

  // database port
  port: 5432,

  // number of rows to return at a time from a prepared statement's
  // portal. 0 will return all rows at once
  rows: 0,

  // binary result mode
  binary: false,

  // Connection pool options - see https://github.com/brianc/node-pg-pool

  // number of connections to use in connection pool
  // 0 will disable connection pooling
  max: 10,

  // max milliseconds a client can go unused before it is removed
  // from the pool and destroyed
  idleTimeoutMillis: 30000,

  client_encoding: '',

  ssl: false,

  application_name: undefined,

  fallback_application_name: undefined,

  parseInputDatesAsUTC: false,

  // max milliseconds any query using this connection will execute for before timing out in error.
  // false=unlimited
  statement_timeout: false,

  // max milliseconds to wait for query to complete (client side)
  query_timeout: false,

  connect_timeout: 0,

  keepalives: 1,

  keepalives_idle: 0
};


// save default parsers
var parseBigInteger = pgTypes.getTypeParser(20, 'text');
var parseBigIntegerArray = pgTypes.getTypeParser(1016, 'text');

// parse int8 so you can get your count values as actual numbers
module.exports.__defineSetter__('parseInt8', function (val) {
  pgTypes.setTypeParser(20, 'text', val ? pgTypes.getTypeParser(23, 'text') : parseBigInteger);
  pgTypes.setTypeParser(1016, 'text', val ? pgTypes.getTypeParser(1007, 'text') : parseBigIntegerArray);
});
});
var defaults_1 = defaults.host;
var defaults_2 = defaults.user;
var defaults_3 = defaults.database;
var defaults_4 = defaults.password;
var defaults_5 = defaults.connectionString;
var defaults_6 = defaults.port;
var defaults_7 = defaults.rows;
var defaults_8 = defaults.binary;
var defaults_9 = defaults.max;
var defaults_10 = defaults.idleTimeoutMillis;
var defaults_11 = defaults.client_encoding;
var defaults_12 = defaults.ssl;
var defaults_13 = defaults.application_name;
var defaults_14 = defaults.fallback_application_name;
var defaults_15 = defaults.parseInputDatesAsUTC;
var defaults_16 = defaults.statement_timeout;
var defaults_17 = defaults.query_timeout;
var defaults_18 = defaults.connect_timeout;
var defaults_19 = defaults.keepalives;
var defaults_20 = defaults.keepalives_idle;

/**
 * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * README.md file in the root directory of this source tree.
 */





function escapeElement (elementRepresentation) {
  var escaped = elementRepresentation
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"');

  return '"' + escaped + '"'
}

// convert a JS array to a postgres array literal
// uses comma separator so won't work for types like box that use
// a different array separator.
function arrayString (val) {
  var result = '{';
  for (var i = 0; i < val.length; i++) {
    if (i > 0) {
      result = result + ',';
    }
    if (val[i] === null || typeof val[i] === 'undefined') {
      result = result + 'NULL';
    } else if (Array.isArray(val[i])) {
      result = result + arrayString(val[i]);
    } else if (val[i] instanceof Buffer) {
      result += '\\\\x' + val[i].toString('hex');
    } else {
      result += escapeElement(prepareValue(val[i]));
    }
  }
  result = result + '}';
  return result
}

// converts values from javascript types
// to their 'raw' counterparts for use as a postgres parameter
// note: you can override this function to provide your own conversion mechanism
// for complex types, etc...
var prepareValue = function (val, seen) {
  if (val instanceof Buffer) {
    return val
  }
  if (ArrayBuffer.isView(val)) {
    var buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
    if (buf.length === val.byteLength) {
      return buf
    }
    return buf.slice(val.byteOffset, val.byteOffset + val.byteLength) // Node.js v4 does not support those Buffer.from params
  }
  if (val instanceof Date) {
    if (defaults.parseInputDatesAsUTC) {
      return dateToStringUTC(val)
    } else {
      return dateToString(val)
    }
  }
  if (Array.isArray(val)) {
    return arrayString(val)
  }
  if (val === null || typeof val === 'undefined') {
    return null
  }
  if (typeof val === 'object') {
    return prepareObject(val, seen)
  }
  return val.toString()
};

function prepareObject (val, seen) {
  if (val && typeof val.toPostgres === 'function') {
    seen = seen || [];
    if (seen.indexOf(val) !== -1) {
      throw new Error('circular reference detected while preparing "' + val + '" for query')
    }
    seen.push(val);

    return prepareValue(val.toPostgres(prepareValue), seen)
  }
  return JSON.stringify(val)
}

function pad (number, digits) {
  number = '' + number;
  while (number.length < digits) { number = '0' + number; }
  return number
}

function dateToString (date) {
  var offset = -date.getTimezoneOffset();

  var year = date.getFullYear();
  var isBCYear = year < 1;
  if (isBCYear) year = Math.abs(year) + 1; // negative years are 1 off their BC representation

  var ret = pad(year, 4) + '-' +
    pad(date.getMonth() + 1, 2) + '-' +
    pad(date.getDate(), 2) + 'T' +
    pad(date.getHours(), 2) + ':' +
    pad(date.getMinutes(), 2) + ':' +
    pad(date.getSeconds(), 2) + '.' +
    pad(date.getMilliseconds(), 3);

  if (offset < 0) {
    ret += '-';
    offset *= -1;
  } else { ret += '+'; }

  ret += pad(Math.floor(offset / 60), 2) + ':' + pad(offset % 60, 2);
  if (isBCYear) ret += ' BC';
  return ret
}

function dateToStringUTC (date) {
  var year = date.getUTCFullYear();
  var isBCYear = year < 1;
  if (isBCYear) year = Math.abs(year) + 1; // negative years are 1 off their BC representation

  var ret = pad(year, 4) + '-' +
    pad(date.getUTCMonth() + 1, 2) + '-' +
    pad(date.getUTCDate(), 2) + 'T' +
    pad(date.getUTCHours(), 2) + ':' +
    pad(date.getUTCMinutes(), 2) + ':' +
    pad(date.getUTCSeconds(), 2) + '.' +
    pad(date.getUTCMilliseconds(), 3);

  ret += '+00:00';
  if (isBCYear) ret += ' BC';
  return ret
}

function normalizeQueryConfig (config, values, callback) {
  // can take in strings or config objects
  config = (typeof (config) === 'string') ? { text: config } : config;
  if (values) {
    if (typeof values === 'function') {
      config.callback = values;
    } else {
      config.values = values;
    }
  }
  if (callback) {
    config.callback = callback;
  }
  return config
}

const md5 = function (string) {
  return crypto.createHash('md5').update(string, 'utf-8').digest('hex')
};

// See AuthenticationMD5Password at https://www.postgresql.org/docs/current/static/protocol-flow.html
const postgresMd5PasswordHash = function (user, password, salt) {
  var inner = md5(password + user);
  var outer = md5(Buffer.concat([Buffer.from(inner), salt]));
  return 'md5' + outer
};

var utils = {
  prepareValue: function prepareValueWrapper (value) {
    // this ensures that extra arguments do not get passed into prepareValue
    // by accident, eg: from calling values.map(utils.prepareValue)
    return prepareValue(value)
  },
  normalizeQueryConfig,
  postgresMd5PasswordHash,
  md5
};

function startSession (mechanisms) {
  if (mechanisms.indexOf('SCRAM-SHA-256') === -1) {
    throw new Error('SASL: Only mechanism SCRAM-SHA-256 is currently supported')
  }

  const clientNonce = crypto.randomBytes(18).toString('base64');

  return {
    mechanism: 'SCRAM-SHA-256',
    clientNonce,
    response: 'n,,n=*,r=' + clientNonce,
    message: 'SASLInitialResponse'
  }
}

function continueSession (session, password, serverData) {
  if (session.message !== 'SASLInitialResponse') {
    throw new Error('SASL: Last message was not SASLInitialResponse')
  }

  const sv = extractVariablesFromFirstServerMessage(serverData);

  if (!sv.nonce.startsWith(session.clientNonce)) {
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce')
  }

  var saltBytes = Buffer.from(sv.salt, 'base64');

  var saltedPassword = Hi(password, saltBytes, sv.iteration);

  var clientKey = createHMAC(saltedPassword, 'Client Key');
  var storedKey = crypto.createHash('sha256').update(clientKey).digest();

  var clientFirstMessageBare = 'n=*,r=' + session.clientNonce;
  var serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration;

  var clientFinalMessageWithoutProof = 'c=biws,r=' + sv.nonce;

  var authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof;

  var clientSignature = createHMAC(storedKey, authMessage);
  var clientProofBytes = xorBuffers(clientKey, clientSignature);
  var clientProof = clientProofBytes.toString('base64');

  var serverKey = createHMAC(saltedPassword, 'Server Key');
  var serverSignatureBytes = createHMAC(serverKey, authMessage);

  session.message = 'SASLResponse';
  session.serverSignature = serverSignatureBytes.toString('base64');
  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof;
}

function finalizeSession (session, serverData) {
  if (session.message !== 'SASLResponse') {
    throw new Error('SASL: Last message was not SASLResponse')
  }

  var serverSignature;

  String(serverData).split(',').forEach(function (part) {
    switch (part[0]) {
      case 'v':
        serverSignature = part.substr(2);
        break
    }
  });

  if (serverSignature !== session.serverSignature) {
    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match')
  }
}

function extractVariablesFromFirstServerMessage (data) {
  var nonce, salt, iteration;

  String(data).split(',').forEach(function (part) {
    switch (part[0]) {
      case 'r':
        nonce = part.substr(2);
        break
      case 's':
        salt = part.substr(2);
        break
      case 'i':
        iteration = parseInt(part.substr(2), 10);
        break
    }
  });

  if (!nonce) {
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing')
  }

  if (!salt) {
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing')
  }

  if (!iteration) {
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing')
  }

  return {
    nonce,
    salt,
    iteration
  }
}

function xorBuffers (a, b) {
  if (!Buffer.isBuffer(a)) a = Buffer.from(a);
  if (!Buffer.isBuffer(b)) b = Buffer.from(b);
  var res = [];
  if (a.length > b.length) {
    for (var i = 0; i < b.length; i++) {
      res.push(a[i] ^ b[i]);
    }
  } else {
    for (var j = 0; j < a.length; j++) {
      res.push(a[j] ^ b[j]);
    }
  }
  return Buffer.from(res)
}

function createHMAC (key, msg) {
  return crypto.createHmac('sha256', key).update(msg).digest()
}

function Hi (password, saltBytes, iterations) {
  var ui1 = createHMAC(password, Buffer.concat([saltBytes, Buffer.from([0, 0, 0, 1])]));
  var ui = ui1;
  for (var i = 0; i < iterations - 1; i++) {
    ui1 = createHMAC(password, ui1);
    ui = xorBuffers(ui, ui1);
  }

  return ui
}

var sasl = {
  startSession,
  continueSession,
  finalizeSession
};

var through_1 = createCommonjsModule(function (module, exports) {
// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through;
through.through = through;

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data); };
  end = end || function () { this.queue(null); };

  var ended = false, destroyed = false, buffer = [], _ended = false;
  var stream$1 = new stream();
  stream$1.readable = stream$1.writable = true;
  stream$1.paused = false;

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream$1.autoDestroy = !(opts && opts.autoDestroy === false);

  stream$1.write = function (data) {
    write.call(this, data);
    return !stream$1.paused
  };

  function drain() {
    while(buffer.length && !stream$1.paused) {
      var data = buffer.shift();
      if(null === data)
        return stream$1.emit('end')
      else
        stream$1.emit('data', data);
    }
  }

  stream$1.queue = stream$1.push = function (data) {
//    console.error(ended)
    if(_ended) return stream$1
    if(data === null) _ended = true;
    buffer.push(data);
    drain();
    return stream$1
  };

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream$1.on('end', function () {
    stream$1.readable = false;
    if(!stream$1.writable && stream$1.autoDestroy)
      process.nextTick(function () {
        stream$1.destroy();
      });
  });

  function _end () {
    stream$1.writable = false;
    end.call(stream$1);
    if(!stream$1.readable && stream$1.autoDestroy)
      stream$1.destroy();
  }

  stream$1.end = function (data) {
    if(ended) return
    ended = true;
    if(arguments.length) stream$1.write(data);
    _end(); // will emit or queue
    return stream$1
  };

  stream$1.destroy = function () {
    if(destroyed) return
    destroyed = true;
    ended = true;
    buffer.length = 0;
    stream$1.writable = stream$1.readable = false;
    stream$1.emit('close');
    return stream$1
  };

  stream$1.pause = function () {
    if(stream$1.paused) return
    stream$1.paused = true;
    return stream$1
  };

  stream$1.resume = function () {
    if(stream$1.paused) {
      stream$1.paused = false;
      stream$1.emit('resume');
    }
    drain();
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream$1.paused)
      stream$1.emit('drain');
    return stream$1
  };
  return stream$1
}
});

//filter will reemit the data if cb(err,pass) pass is truthy

// reduce is more tricky
// maybe we want to group the reductions or emit progress updates occasionally
// the most basic reduce just emits one 'data' event after it has recieved 'end'



var Decoder = string_decoder.StringDecoder;

var split_1 = split;

//TODO pass in a function to map across the lines.

function split (matcher, mapper, options) {
  var decoder = new Decoder();
  var soFar = '';
  var maxLength = options && options.maxLength;
  var trailing = options && options.trailing === false ? false : true;
  if('function' === typeof matcher)
    mapper = matcher, matcher = null;
  if (!matcher)
    matcher = /\r?\n/;

  function emit(stream, piece) {
    if(mapper) {
      try {
        piece = mapper(piece);
      }
      catch (err) {
        return stream.emit('error', err)
      }
      if('undefined' !== typeof piece)
        stream.queue(piece);
    }
    else
      stream.queue(piece);
  }

  function next (stream, buffer) {
    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher);
    soFar = pieces.pop();

    if (maxLength && soFar.length > maxLength)
      return stream.emit('error', new Error('maximum buffer reached'))

    for (var i = 0; i < pieces.length; i++) {
      var piece = pieces[i];
      emit(stream, piece);
    }
  }

  return through_1(function (b) {
    next(this, decoder.write(b));
  },
  function () {
    if(decoder.end)
      next(this, decoder.end());
    if(trailing && soFar != null)
      emit(this, soFar);
    this.queue(null);
  })
}

var helper = createCommonjsModule(function (module) {

var Stream = stream.Stream
  , defaultPort = 5432
  , isWin = (process.platform === 'win32')
  , warnStream = process.stderr
;


var S_IRWXG = 56     //    00070(8)
  , S_IRWXO = 7      //    00007(8)
  , S_IFMT  = 61440  // 00170000(8)
  , S_IFREG = 32768  //  0100000(8)
;
function isRegFile(mode) {
    return ((mode & S_IFMT) == S_IFREG);
}

var fieldNames = [ 'host', 'port', 'database', 'user', 'password' ];
var nrOfFields = fieldNames.length;
var passKey = fieldNames[ nrOfFields -1 ];


function warn() {
    var isWritable = (
        warnStream instanceof Stream &&
          true === warnStream.writable
    );

    if (isWritable) {
        var args = Array.prototype.slice.call(arguments).concat("\n");
        warnStream.write( util.format.apply(util, args) );
    }
}


Object.defineProperty(module.exports, 'isWin', {
    get : function() {
        return isWin;
    } ,
    set : function(val) {
        isWin = val;
    }
});


module.exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
};

module.exports.getFileName = function(env){
    env = env || process.env;
    var file = env.PGPASSFILE || (
        isWin ?
          path.join( env.APPDATA , 'postgresql', 'pgpass.conf' ) :
          path.join( env.HOME, '.pgpass' )
    );
    return file;
};

module.exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, 'PGPASSWORD')) {
        return false;
    }

    if (isWin) {
        return true;
    }

    fname = fname || '<unkn>';

    if (! isRegFile(stats.mode)) {
        warn('WARNING: password file "%s" is not a plain file', fname);
        return false;
    }

    if (stats.mode & (S_IRWXG | S_IRWXO)) {
        /* If password file is insecure, alert the user and ignore it. */
        warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
        return false;
    }

    return true;
};


var matcher = module.exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx){
        if (idx == 1) {
            // the port
            if ( Number( connInfo[field] || defaultPort ) === Number( entry[field] ) ) {
                return prev && true;
            }
        }
        return prev && (
            entry[field] === '*' ||
              entry[field] === connInfo[field]
        );
    }, true);
};


module.exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(new split_1());

    function onLine(line) {
        var entry = parseLine(line);
        if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
            pass = entry[passKey];
            lineStream.end(); // -> calls onEnd(), but pass is set now
        }
    }

    var onEnd = function() {
        stream.destroy();
        cb(pass);
    };

    var onErr = function(err) {
        stream.destroy();
        warn('WARNING: error on reading file: %s', err);
        cb(undefined);
    };

    stream.on('error', onErr);
    lineStream
        .on('data', onLine)
        .on('end', onEnd)
        .on('error', onErr)
    ;

};


var parseLine = module.exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
        return null;
    }

    var curChar = '';
    var prevChar = '';
    var fieldIdx = 0;
    var startIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
        var field = line.substring(i0, i1);

        if (! Object.hasOwnProperty.call(process.env, 'PGPASS_NO_DEESCAPE')) {
            field = field.replace(/\\([:\\])/g, '$1');
        }

        obj[ fieldNames[idx] ] = field;
    };

    for (var i = 0 ; i < line.length-1 ; i += 1) {
        curChar = line.charAt(i+1);
        prevChar = line.charAt(i);

        isLastField = (fieldIdx == nrOfFields-1);

        if (isLastField) {
            addToObj(fieldIdx, startIdx);
            break;
        }

        if (i >= 0 && curChar == ':' && prevChar !== '\\') {
            addToObj(fieldIdx, startIdx, i+1);

            startIdx = i+2;
            fieldIdx += 1;
        }
    }

    obj = ( Object.keys(obj).length === nrOfFields ) ? obj : null;

    return obj;
};


var isValidEntry = module.exports.isValidEntry = function(entry){
    var rules = {
        // host
        0 : function(x){
            return x.length > 0;
        } ,
        // port
        1 : function(x){
            if (x === '*') {
                return true;
            }
            x = Number(x);
            return (
                isFinite(x) &&
                  x > 0 &&
                  x < 9007199254740992 &&
                  Math.floor(x) === x
            );
        } ,
        // database
        2 : function(x){
            return x.length > 0;
        } ,
        // username
        3 : function(x){
            return x.length > 0;
        } ,
        // password
        4 : function(x){
            return x.length > 0;
        }
    };

    for (var idx = 0 ; idx < fieldNames.length ; idx += 1) {
        var rule = rules[idx];
        var value = entry[ fieldNames[idx] ] || '';

        var res = rule(value);
        if (!res) {
            return false;
        }
    }

    return true;
};
});
var helper_1 = helper.warnTo;
var helper_2 = helper.getFileName;
var helper_3 = helper.usePgPass;
var helper_4 = helper.match;
var helper_5 = helper.getPassword;
var helper_6 = helper.parseLine;
var helper_7 = helper.isValidEntry;

var lib = function(connInfo, cb) {
    var file = helper.getFileName();
    
    fs.stat(file, function(err, stat){
        if (err || !helper.usePgPass(stat, file)) {
            return cb(undefined);
        }

        var st = fs.createReadStream(file);

        helper.getPassword(connInfo, st, cb);
    });
};

var warnTo = helper.warnTo;
lib.warnTo = warnTo;

/**
 * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * README.md file in the root directory of this source tree.
 */



function TypeOverrides (userTypes) {
  this._types = userTypes || pgTypes;
  this.text = {};
  this.binary = {};
}

TypeOverrides.prototype.getOverrides = function (format) {
  switch (format) {
    case 'text': return this.text
    case 'binary': return this.binary
    default: return {}
  }
};

TypeOverrides.prototype.setTypeParser = function (oid, format, parseFn) {
  if (typeof format === 'function') {
    parseFn = format;
    format = 'text';
  }
  this.getOverrides(format)[oid] = parseFn;
};

TypeOverrides.prototype.getTypeParser = function (oid, format) {
  format = format || 'text';
  return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format)
};

var typeOverrides = TypeOverrides;

//Parse method copied from https://github.com/brianc/node-postgres
//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)
//MIT License

//parses a connection string
function parse$2(str) {
  var config;
  //unix socket
  if(str.charAt(0) === '/') {
    config = str.split(' ');
    return { host: config[0], database: config[1] };
  }
  // url parse expects spaces encoded as %20
  if(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
    str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
  }
  var result = url.parse(str, true);
  config = {};

  if (result.query.application_name) {
    config.application_name = result.query.application_name;
  }
  if (result.query.fallback_application_name) {
    config.fallback_application_name = result.query.fallback_application_name;
  }

  config.port = result.port;
  if(result.protocol == 'socket:') {
    config.host = decodeURI(result.pathname);
    config.database = result.query.db;
    config.client_encoding = result.query.encoding;
    return config;
  }
  config.host = result.hostname;

  // result.pathname is not always guaranteed to have a '/' prefix (e.g. relative urls)
  // only strip the slash if it is present.
  var pathname = result.pathname;
  if (pathname && pathname.charAt(0) === '/') {
    pathname = result.pathname.slice(1) || null;
  }
  config.database = pathname && decodeURI(pathname);

  var auth = (result.auth || ':').split(':');
  config.user = auth[0];
  config.password = auth.splice(1).join(':');

  var ssl = result.query.ssl;
  if (ssl === 'true' || ssl === '1') {
    config.ssl = true;
  }

  return config;
}

var pgConnectionString = {
  parse: parse$2
};

/**
 * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * README.md file in the root directory of this source tree.
 */





var parse$3 = pgConnectionString.parse; // parses a connection string

var val = function (key, config, envVar) {
  if (envVar === undefined) {
    envVar = process.env['PG' + key.toUpperCase()];
  } else if (envVar === false) ; else {
    envVar = process.env[envVar];
  }

  return config[key] ||
    envVar ||
    defaults[key]
};

var useSsl = function () {
  switch (process.env.PGSSLMODE) {
    case 'disable':
      return false
    case 'prefer':
    case 'require':
    case 'verify-ca':
    case 'verify-full':
      return true
  }
  return defaults.ssl
};

var ConnectionParameters = function (config) {
  // if a string is passed, it is a raw connection string so we parse it into a config
  config = typeof config === 'string' ? parse$3(config) : config || {};

  // if the config has a connectionString defined, parse IT into the config we use
  // this will override other default values with what is stored in connectionString
  if (config.connectionString) {
    config = Object.assign({}, config, parse$3(config.connectionString));
  }

  this.user = val('user', config);
  this.database = val('database', config);
  this.port = parseInt(val('port', config), 10);
  this.host = val('host', config);
  this.password = val('password', config);
  this.binary = val('binary', config);
  this.ssl = typeof config.ssl === 'undefined' ? useSsl() : config.ssl;
  this.client_encoding = val('client_encoding', config);
  this.replication = val('replication', config);
  // a domain socket begins with '/'
  this.isDomainSocket = (!(this.host || '').indexOf('/'));

  this.application_name = val('application_name', config, 'PGAPPNAME');
  this.fallback_application_name = val('fallback_application_name', config, false);
  this.statement_timeout = val('statement_timeout', config, false);
  this.query_timeout = val('query_timeout', config, false);

  if (config.connectionTimeoutMillis === undefined) {
    this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
  } else {
    this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
  }

  if (config.keepAlive === false) {
    this.keepalives = 0;
  } else if (config.keepAlive === true) {
    this.keepalives = 1;
  }

  if (typeof config.keepAliveInitialDelayMillis === 'number') {
    this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
  }
};

// Convert arg to a string, surround in single quotes, and escape single quotes and backslashes
var quoteParamValue = function (value) {
  return "'" + ('' + value).replace(/\\/g, '\\\\').replace(/'/g, "\\'") + "'"
};

var add = function (params, config, paramName) {
  var value = config[paramName];
  if (value !== undefined && value !== null) {
    params.push(paramName + '=' + quoteParamValue(value));
  }
};

ConnectionParameters.prototype.getLibpqConnectionString = function (cb) {
  var params = [];
  add(params, this, 'user');
  add(params, this, 'password');
  add(params, this, 'port');
  add(params, this, 'application_name');
  add(params, this, 'fallback_application_name');
  add(params, this, 'connect_timeout');

  var ssl = typeof this.ssl === 'object' ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
  add(params, ssl, 'sslmode');
  add(params, ssl, 'sslca');
  add(params, ssl, 'sslkey');
  add(params, ssl, 'sslcert');
  add(params, ssl, 'sslrootcert');

  if (this.database) {
    params.push('dbname=' + quoteParamValue(this.database));
  }
  if (this.replication) {
    params.push('replication=' + quoteParamValue(this.replication));
  }
  if (this.host) {
    params.push('host=' + quoteParamValue(this.host));
  }
  if (this.isDomainSocket) {
    return cb(null, params.join(' '))
  }
  if (this.client_encoding) {
    params.push('client_encoding=' + quoteParamValue(this.client_encoding));
  }
  dns.lookup(this.host, function (err, address) {
    if (err) return cb(err, null)
    params.push('hostaddr=' + quoteParamValue(address));
    return cb(null, params.join(' '))
  });
};

var connectionParameters = ConnectionParameters;

/**
 * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * README.md file in the root directory of this source tree.
 */



// result object returned from query
// in the 'end' event and also
// passed as second argument to provided callback
var Result = function (rowMode, types) {
  this.command = null;
  this.rowCount = null;
  this.oid = null;
  this.rows = [];
  this.fields = [];
  this._parsers = [];
  this._types = types;
  this.RowCtor = null;
  this.rowAsArray = rowMode === 'array';
  if (this.rowAsArray) {
    this.parseRow = this._parseRowAsArray;
  }
};

var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

// adds a command complete message
Result.prototype.addCommandComplete = function (msg) {
  var match;
  if (msg.text) {
    // pure javascript
    match = matchRegexp.exec(msg.text);
  } else {
    // native bindings
    match = matchRegexp.exec(msg.command);
  }
  if (match) {
    this.command = match[1];
    if (match[3]) {
      // COMMMAND OID ROWS
      this.oid = parseInt(match[2], 10);
      this.rowCount = parseInt(match[3], 10);
    } else if (match[2]) {
      // COMMAND ROWS
      this.rowCount = parseInt(match[2], 10);
    }
  }
};

Result.prototype._parseRowAsArray = function (rowData) {
  var row = [];
  for (var i = 0, len = rowData.length; i < len; i++) {
    var rawValue = rowData[i];
    if (rawValue !== null) {
      row.push(this._parsers[i](rawValue));
    } else {
      row.push(null);
    }
  }
  return row
};

Result.prototype.parseRow = function (rowData) {
  var row = {};
  for (var i = 0, len = rowData.length; i < len; i++) {
    var rawValue = rowData[i];
    var field = this.fields[i].name;
    if (rawValue !== null) {
      row[field] = this._parsers[i](rawValue);
    } else {
      row[field] = null;
    }
  }
  return row
};

Result.prototype.addRow = function (row) {
  this.rows.push(row);
};

Result.prototype.addFields = function (fieldDescriptions) {
  // clears field definitions
  // multiple query statements in 1 action can result in multiple sets
  // of rowDescriptions...eg: 'select NOW(); select 1::int;'
  // you need to reset the fields
  if (this.fields.length) {
    this.fields = [];
    this._parsers = [];
  }
  for (var i = 0; i < fieldDescriptions.length; i++) {
    var desc = fieldDescriptions[i];
    this.fields.push(desc);
    var parser = (this._types || pgTypes).getTypeParser(desc.dataTypeID, desc.format || 'text');
    this._parsers.push(parser);
  }
};

var result = Result;

/**
 * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * README.md file in the root directory of this source tree.
 */

var EventEmitter = events.EventEmitter;





var Query = function (config, values, callback) {
  // use of "new" optional
  if (!(this instanceof Query)) { return new Query(config, values, callback) }

  config = utils.normalizeQueryConfig(config, values, callback);

  this.text = config.text;
  this.values = config.values;
  this.rows = config.rows;
  this.types = config.types;
  this.name = config.name;
  this.binary = config.binary;
  // use unique portal name each time
  this.portal = config.portal || '';
  this.callback = config.callback;
  this._rowMode = config.rowMode;
  if (process.domain && config.callback) {
    this.callback = process.domain.bind(config.callback);
  }
  this._result = new result(this._rowMode, this.types);

  // potential for multiple results
  this._results = this._result;
  this.isPreparedStatement = false;
  this._canceledDueToError = false;
  this._promise = null;
  EventEmitter.call(this);
};

util.inherits(Query, EventEmitter);

Query.prototype.requiresPreparation = function () {
  // named queries must always be prepared
  if (this.name) { return true }
  // always prepare if there are max number of rows expected per
  // portal execution
  if (this.rows) { return true }
  // don't prepare empty text queries
  if (!this.text) { return false }
  // prepare if there are values
  if (!this.values) { return false }
  return this.values.length > 0
};

Query.prototype._checkForMultirow = function () {
  // if we already have a result with a command property
  // then we've already executed one query in a multi-statement simple query
  // turn our results into an array of results
  if (this._result.command) {
    if (!Array.isArray(this._results)) {
      this._results = [this._result];
    }
    this._result = new result(this._rowMode, this.types);
    this._results.push(this._result);
  }
};

// associates row metadata from the supplied
// message with this query object
// metadata used when parsing row results
Query.prototype.handleRowDescription = function (msg) {
  this._checkForMultirow();
  this._result.addFields(msg.fields);
  this._accumulateRows = this.callback || !this.listeners('row').length;
};

Query.prototype.handleDataRow = function (msg) {
  var row;

  if (this._canceledDueToError) {
    return
  }

  try {
    row = this._result.parseRow(msg.fields);
  } catch (err) {
    this._canceledDueToError = err;
    return
  }

  this.emit('row', row, this._result);
  if (this._accumulateRows) {
    this._result.addRow(row);
  }
};

Query.prototype.handleCommandComplete = function (msg, con) {
  this._checkForMultirow();
  this._result.addCommandComplete(msg);
  // need to sync after each command complete of a prepared statement
  if (this.isPreparedStatement) {
    con.sync();
  }
};

// if a named prepared statement is created with empty query text
// the backend will send an emptyQuery message but *not* a command complete message
// execution on the connection will hang until the backend receives a sync message
Query.prototype.handleEmptyQuery = function (con) {
  if (this.isPreparedStatement) {
    con.sync();
  }
};

Query.prototype.handleReadyForQuery = function (con) {
  if (this._canceledDueToError) {
    return this.handleError(this._canceledDueToError, con)
  }
  if (this.callback) {
    this.callback(null, this._results);
  }
  this.emit('end', this._results);
};

Query.prototype.handleError = function (err, connection) {
  // need to sync after error during a prepared statement
  if (this.isPreparedStatement) {
    connection.sync();
  }
  if (this._canceledDueToError) {
    err = this._canceledDueToError;
    this._canceledDueToError = false;
  }
  // if callback supplied do not emit error event as uncaught error
  // events will bubble up to node process
  if (this.callback) {
    return this.callback(err)
  }
  this.emit('error', err);
};

Query.prototype.submit = function (connection) {
  if (typeof this.text !== 'string' && typeof this.name !== 'string') {
    return new Error('A query must have either text or a name. Supplying neither is unsupported.')
  }
  const previous = connection.parsedStatements[this.name];
  if (this.text && previous && this.text !== previous) {
    return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)
  }
  if (this.values && !Array.isArray(this.values)) {
    return new Error('Query values must be an array')
  }
  if (this.requiresPreparation()) {
    this.prepare(connection);
  } else {
    connection.query(this.text);
  }
  return null
};

Query.prototype.hasBeenParsed = function (connection) {
  return this.name && connection.parsedStatements[this.name]
};

Query.prototype.handlePortalSuspended = function (connection) {
  this._getRows(connection, this.rows);
};

Query.prototype._getRows = function (connection, rows) {
  connection.execute({
    portal: this.portal,
    rows: rows
  }, true);
  connection.flush();
};

Query.prototype.prepare = function (connection) {
  var self = this;
  // prepared statements need sync to be called after each command
  // complete or when an error is encountered
  this.isPreparedStatement = true;
  // TODO refactor this poor encapsulation
  if (!this.hasBeenParsed(connection)) {
    connection.parse({
      text: self.text,
      name: self.name,
      types: self.types
    }, true);
  }

  if (self.values) {
    try {
      self.values = self.values.map(utils.prepareValue);
    } catch (err) {
      this.handleError(err, connection);
      return
    }
  }

  // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
  connection.bind({
    portal: self.portal,
    statement: self.name,
    values: self.values,
    binary: self.binary
  }, true);

  connection.describe({
    type: 'P',
    name: self.portal || ''
  }, true);

  this._getRows(connection, this.rows);
};

Query.prototype.handleCopyInResponse = function (connection) {
  connection.sendCopyFail('No source stream defined');
};

// eslint-disable-next-line no-unused-vars
Query.prototype.handleCopyData = function (msg, connection) {
  // noop
};
var query = Query;

var bufferWriter = createCommonjsModule(function (module) {
//binary data writer tuned for creating
//postgres message packets as effeciently as possible by reusing the
//same buffer to avoid memcpy and limit memory allocations
var Writer = module.exports = function (size) {
  this.size = size || 1024;
  this.buffer = Buffer.alloc(this.size + 5);
  this.offset = 5;
  this.headerPosition = 0;
};

//resizes internal buffer if not enough size left
Writer.prototype._ensure = function (size) {
  var remaining = this.buffer.length - this.offset;
  if (remaining < size) {
    var oldBuffer = this.buffer;
    // exponential growth factor of around ~ 1.5
    // https://stackoverflow.com/questions/2269063/buffer-growth-strategy
    var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
    this.buffer = Buffer.alloc(newSize);
    oldBuffer.copy(this.buffer);
  }
};

Writer.prototype.addInt32 = function (num) {
  this._ensure(4);
  this.buffer[this.offset++] = (num >>> 24 & 0xFF);
  this.buffer[this.offset++] = (num >>> 16 & 0xFF);
  this.buffer[this.offset++] = (num >>> 8 & 0xFF);
  this.buffer[this.offset++] = (num >>> 0 & 0xFF);
  return this;
};

Writer.prototype.addInt16 = function (num) {
  this._ensure(2);
  this.buffer[this.offset++] = (num >>> 8 & 0xFF);
  this.buffer[this.offset++] = (num >>> 0 & 0xFF);
  return this;
};

//for versions of node requiring 'length' as 3rd argument to buffer.write
var writeString = function (buffer, string, offset, len) {
  buffer.write(string, offset, len);
};

//overwrite function for older versions of node
if (Buffer.prototype.write.length === 3) {
  writeString = function (buffer, string, offset, len) {
    buffer.write(string, offset);
  };
}

Writer.prototype.addCString = function (string) {
  //just write a 0 for empty or null strings
  if (!string) {
    this._ensure(1);
  } else {
    var len = Buffer.byteLength(string);
    this._ensure(len + 1); //+1 for null terminator
    writeString(this.buffer, string, this.offset, len);
    this.offset += len;
  }

  this.buffer[this.offset++] = 0; // null terminator
  return this;
};

Writer.prototype.addChar = function (c) {
  this._ensure(1);
  writeString(this.buffer, c, this.offset, 1);
  this.offset++;
  return this;
};

Writer.prototype.addString = function (string) {
  string = string || "";
  var len = Buffer.byteLength(string);
  this._ensure(len);
  this.buffer.write(string, this.offset);
  this.offset += len;
  return this;
};

Writer.prototype.getByteLength = function () {
  return this.offset - 5;
};

Writer.prototype.add = function (otherBuffer) {
  this._ensure(otherBuffer.length);
  otherBuffer.copy(this.buffer, this.offset);
  this.offset += otherBuffer.length;
  return this;
};

Writer.prototype.clear = function () {
  this.offset = 5;
  this.headerPosition = 0;
  this.lastEnd = 0;
};

//appends a header block to all the written data since the last
//subsequent header or to the beginning if there is only one data block
Writer.prototype.addHeader = function (code, last) {
  var origOffset = this.offset;
  this.offset = this.headerPosition;
  this.buffer[this.offset++] = code;
  //length is everything in this packet minus the code
  this.addInt32(origOffset - (this.headerPosition + 1));
  //set next header position
  this.headerPosition = origOffset;
  //make space for next header
  this.offset = origOffset;
  if (!last) {
    this._ensure(5);
    this.offset += 5;
  }
};

Writer.prototype.join = function (code) {
  if (code) {
    this.addHeader(code, true);
  }
  return this.buffer.slice(code ? 0 : 5, this.offset);
};

Writer.prototype.flush = function (code) {
  var result = this.join(code);
  this.clear();
  return result;
};
});

var packetReader = createCommonjsModule(function (module) {
var Reader = module.exports = function(options) {
  //TODO - remove for version 1.0
  if(typeof options == 'number') {
    options = { headerSize: options };
  }
  options = options || {};
  this.offset = 0;
  this.lastChunk = false;
  this.chunk = null;
  this.chunkLength = 0;
  this.headerSize = options.headerSize || 0;
  this.lengthPadding = options.lengthPadding || 0;
  this.header = null;
  assert(this.headerSize < 2, 'pre-length header of more than 1 byte length not currently supported');
};

Reader.prototype.addChunk = function(chunk) {
  if (!this.chunk || this.offset === this.chunkLength) {
    this.chunk = chunk;
    this.chunkLength = chunk.length;
    this.offset = 0;
    return
  }

  var newChunkLength = chunk.length;
  var newLength = this.chunkLength + newChunkLength;

  if (newLength > this.chunk.length) {
    var newBufferLength = this.chunk.length * 2;
    while (newLength >= newBufferLength) {
      newBufferLength *= 2;
    }
    var newBuffer = Buffer.alloc(newBufferLength);
    this.chunk.copy(newBuffer);
    this.chunk = newBuffer;
  }
  chunk.copy(this.chunk, this.chunkLength);
  this.chunkLength = newLength;
};

Reader.prototype.read = function() {
  if(this.chunkLength < (this.headerSize + 4 + this.offset)) {
    return false
  }

  if(this.headerSize) {
    this.header = this.chunk[this.offset];
  }

  //read length of next item
  var length = this.chunk.readUInt32BE(this.offset + this.headerSize) + this.lengthPadding;

  //next item spans more chunks than we have
  var remaining = this.chunkLength - (this.offset + 4 + this.headerSize);
  if(length > remaining) {
    return false
  }

  this.offset += (this.headerSize + 4);
  var result = this.chunk.slice(this.offset, this.offset + length);
  this.offset += length;
  return result
};
});

/**
 * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * README.md file in the root directory of this source tree.
 */


var EventEmitter$1 = events.EventEmitter;





var TEXT_MODE = 0;
var BINARY_MODE = 1;
var Connection = function (config) {
  EventEmitter$1.call(this);
  config = config || {};
  this.stream = config.stream || new net.Socket();
  this._keepAlive = config.keepAlive;
  this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
  this.lastBuffer = false;
  this.lastOffset = 0;
  this.buffer = null;
  this.offset = null;
  this.encoding = config.encoding || 'utf8';
  this.parsedStatements = {};
  this.writer = new bufferWriter();
  this.ssl = config.ssl || false;
  this._ending = false;
  this._mode = TEXT_MODE;
  this._emitMessage = false;
  this._reader = new packetReader({
    headerSize: 1,
    lengthPadding: -4
  });
  var self = this;
  this.on('newListener', function (eventName) {
    if (eventName === 'message') {
      self._emitMessage = true;
    }
  });
};

util.inherits(Connection, EventEmitter$1);

Connection.prototype.connect = function (port, host) {
  var self = this;

  if (this.stream.readyState === 'closed') {
    this.stream.connect(port, host);
  } else if (this.stream.readyState === 'open') {
    this.emit('connect');
  }

  this.stream.on('connect', function () {
    if (self._keepAlive) {
      self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);
    }
    self.emit('connect');
  });

  const reportStreamError = function (error) {
    // don't raise ECONNRESET errors - they can & should be ignored
    // during disconnect
    if (self._ending && error.code === 'ECONNRESET') {
      return
    }
    self.emit('error', error);
  };
  this.stream.on('error', reportStreamError);

  this.stream.on('close', function () {
    self.emit('end');
  });

  if (!this.ssl) {
    return this.attachListeners(this.stream)
  }

  this.stream.once('data', function (buffer) {
    var responseCode = buffer.toString('utf8');
    switch (responseCode) {
      case 'N': // Server does not support SSL connections
        return self.emit('error', new Error('The server does not support SSL connections'))
      case 'S': // Server supports SSL connections, continue with a secure connection
        break
      default: // Any other response byte, including 'E' (ErrorResponse) indicating a server error
        return self.emit('error', new Error('There was an error establishing an SSL connection'))
    }
    var tls$1 = tls;
    self.stream = tls$1.connect({
      socket: self.stream,
      servername: host,
      checkServerIdentity: self.ssl.checkServerIdentity || tls$1.checkServerIdentity,
      rejectUnauthorized: self.ssl.rejectUnauthorized,
      ca: self.ssl.ca,
      pfx: self.ssl.pfx,
      key: self.ssl.key,
      passphrase: self.ssl.passphrase,
      cert: self.ssl.cert,
      secureOptions: self.ssl.secureOptions,
      NPNProtocols: self.ssl.NPNProtocols
    });
    self.attachListeners(self.stream);
    self.stream.on('error', reportStreamError);

    self.emit('sslconnect');
  });
};

Connection.prototype.attachListeners = function (stream) {
  var self = this;
  stream.on('data', function (buff) {
    self._reader.addChunk(buff);
    var packet = self._reader.read();
    while (packet) {
      var msg = self.parseMessage(packet);
      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name;
      if (self._emitMessage) {
        self.emit('message', msg);
      }
      self.emit(eventName, msg);
      packet = self._reader.read();
    }
  });
  stream.on('end', function () {
    self.emit('end');
  });
};

Connection.prototype.requestSsl = function () {
  var bodyBuffer = this.writer
    .addInt16(0x04D2)
    .addInt16(0x162F).flush();

  var length = bodyBuffer.length + 4;

  var buffer = new bufferWriter()
    .addInt32(length)
    .add(bodyBuffer)
    .join();
  this.stream.write(buffer);
};

Connection.prototype.startup = function (config) {
  var writer = this.writer
    .addInt16(3)
    .addInt16(0);

  Object.keys(config).forEach(function (key) {
    var val = config[key];
    writer.addCString(key).addCString(val);
  });

  writer.addCString('client_encoding').addCString("'utf-8'");

  var bodyBuffer = writer.addCString('').flush();
  // this message is sent without a code

  var length = bodyBuffer.length + 4;

  var buffer = new bufferWriter()
    .addInt32(length)
    .add(bodyBuffer)
    .join();
  this.stream.write(buffer);
};

Connection.prototype.cancel = function (processID, secretKey) {
  var bodyBuffer = this.writer
    .addInt16(1234)
    .addInt16(5678)
    .addInt32(processID)
    .addInt32(secretKey)
    .flush();

  var length = bodyBuffer.length + 4;

  var buffer = new bufferWriter()
    .addInt32(length)
    .add(bodyBuffer)
    .join();
  this.stream.write(buffer);
};

Connection.prototype.password = function (password) {
  // 0x70 = 'p'
  this._send(0x70, this.writer.addCString(password));
};

Connection.prototype.sendSASLInitialResponseMessage = function (mechanism, initialResponse) {
  // 0x70 = 'p'
  this.writer
    .addCString(mechanism)
    .addInt32(Buffer.byteLength(initialResponse))
    .addString(initialResponse);

  this._send(0x70);
};

Connection.prototype.sendSCRAMClientFinalMessage = function (additionalData) {
  // 0x70 = 'p'
  this.writer
    .addString(additionalData);

  this._send(0x70);
};

Connection.prototype._send = function (code, more) {
  if (!this.stream.writable) {
    return false
  }
  if (more === true) {
    this.writer.addHeader(code);
  } else {
    return this.stream.write(this.writer.flush(code))
  }
};

Connection.prototype.query = function (text) {
  // 0x51 = Q
  this.stream.write(this.writer.addCString(text).flush(0x51));
};

// send parse message
// "more" === true to buffer the message until flush() is called
Connection.prototype.parse = function (query, more) {
  // expect something like this:
  // { name: 'queryName',
  //   text: 'select * from blah',
  //   types: ['int8', 'bool'] }

  // normalize missing query names to allow for null
  query.name = query.name || '';
  if (query.name.length > 63) {
    /* eslint-disable no-console */
    console.error('Warning! Postgres only supports 63 characters for query names.');
    console.error('You supplied %s (%s)', query.name, query.name.length);
    console.error('This can cause conflicts and silent errors executing queries');
    /* eslint-enable no-console */
  }
  // normalize null type array
  query.types = query.types || [];
  var len = query.types.length;
  var buffer = this.writer
    .addCString(query.name) // name of query
    .addCString(query.text) // actual query text
    .addInt16(len);
  for (var i = 0; i < len; i++) {
    buffer.addInt32(query.types[i]);
  }

  var code = 0x50;
  this._send(code, more);
};

// send bind message
// "more" === true to buffer the message until flush() is called
Connection.prototype.bind = function (config, more) {
  // normalize config
  config = config || {};
  config.portal = config.portal || '';
  config.statement = config.statement || '';
  config.binary = config.binary || false;
  var values = config.values || [];
  var len = values.length;
  var useBinary = false;
  for (var j = 0; j < len; j++) { useBinary |= values[j] instanceof Buffer; }
  var buffer = this.writer
    .addCString(config.portal)
    .addCString(config.statement);
  if (!useBinary) { buffer.addInt16(0); } else {
    buffer.addInt16(len);
    for (j = 0; j < len; j++) { buffer.addInt16(values[j] instanceof Buffer); }
  }
  buffer.addInt16(len);
  for (var i = 0; i < len; i++) {
    var val = values[i];
    if (val === null || typeof val === 'undefined') {
      buffer.addInt32(-1);
    } else if (val instanceof Buffer) {
      buffer.addInt32(val.length);
      buffer.add(val);
    } else {
      buffer.addInt32(Buffer.byteLength(val));
      buffer.addString(val);
    }
  }

  if (config.binary) {
    buffer.addInt16(1); // format codes to use binary
    buffer.addInt16(1);
  } else {
    buffer.addInt16(0); // format codes to use text
  }
  // 0x42 = 'B'
  this._send(0x42, more);
};

// send execute message
// "more" === true to buffer the message until flush() is called
Connection.prototype.execute = function (config, more) {
  config = config || {};
  config.portal = config.portal || '';
  config.rows = config.rows || '';
  this.writer
    .addCString(config.portal)
    .addInt32(config.rows);

  // 0x45 = 'E'
  this._send(0x45, more);
};

var emptyBuffer = Buffer.alloc(0);

Connection.prototype.flush = function () {
  // 0x48 = 'H'
  this.writer.add(emptyBuffer);
  this._send(0x48);
};

Connection.prototype.sync = function () {
  // clear out any pending data in the writer
  this.writer.flush(0);

  this.writer.add(emptyBuffer);
  this._ending = true;
  this._send(0x53);
};

const END_BUFFER = Buffer.from([0x58, 0x00, 0x00, 0x00, 0x04]);

Connection.prototype.end = function () {
  // 0x58 = 'X'
  this.writer.add(emptyBuffer);
  this._ending = true;
  return this.stream.write(END_BUFFER, () => {
    this.stream.end();
  })
};

Connection.prototype.close = function (msg, more) {
  this.writer.addCString(msg.type + (msg.name || ''));
  this._send(0x43, more);
};

Connection.prototype.describe = function (msg, more) {
  this.writer.addCString(msg.type + (msg.name || ''));
  this._send(0x44, more);
};

Connection.prototype.sendCopyFromChunk = function (chunk) {
  this.stream.write(this.writer.add(chunk).flush(0x64));
};

Connection.prototype.endCopyFrom = function () {
  this.stream.write(this.writer.add(emptyBuffer).flush(0x63));
};

Connection.prototype.sendCopyFail = function (msg) {
  // this.stream.write(this.writer.add(emptyBuffer).flush(0x66));
  this.writer.addCString(msg);
  this._send(0x66);
};

var Message = function (name, length) {
  this.name = name;
  this.length = length;
};

Connection.prototype.parseMessage = function (buffer) {
  this.offset = 0;
  var length = buffer.length + 4;
  switch (this._reader.header) {
    case 0x52: // R
      return this.parseR(buffer, length)

    case 0x53: // S
      return this.parseS(buffer, length)

    case 0x4b: // K
      return this.parseK(buffer, length)

    case 0x43: // C
      return this.parseC(buffer, length)

    case 0x5a: // Z
      return this.parseZ(buffer, length)

    case 0x54: // T
      return this.parseT(buffer, length)

    case 0x44: // D
      return this.parseD(buffer, length)

    case 0x45: // E
      return this.parseE(buffer, length)

    case 0x4e: // N
      return this.parseN(buffer, length)

    case 0x31: // 1
      return new Message('parseComplete', length)

    case 0x32: // 2
      return new Message('bindComplete', length)

    case 0x33: // 3
      return new Message('closeComplete', length)

    case 0x41: // A
      return this.parseA(buffer, length)

    case 0x6e: // n
      return new Message('noData', length)

    case 0x49: // I
      return new Message('emptyQuery', length)

    case 0x73: // s
      return new Message('portalSuspended', length)

    case 0x47: // G
      return this.parseG(buffer, length)

    case 0x48: // H
      return this.parseH(buffer, length)

    case 0x57: // W
      return new Message('replicationStart', length)

    case 0x63: // c
      return new Message('copyDone', length)

    case 0x64: // d
      return this.parsed(buffer, length)
  }
};

Connection.prototype.parseR = function (buffer, length) {
  var code = this.parseInt32(buffer);

  var msg = new Message('authenticationOk', length);

  switch (code) {
    case 0: // AuthenticationOk
      return msg
    case 3: // AuthenticationCleartextPassword
      if (msg.length === 8) {
        msg.name = 'authenticationCleartextPassword';
        return msg
      }
      break
    case 5: // AuthenticationMD5Password
      if (msg.length === 12) {
        msg.name = 'authenticationMD5Password';
        msg.salt = Buffer.alloc(4);
        buffer.copy(msg.salt, 0, this.offset, this.offset + 4);
        this.offset += 4;
        return msg
      }

      break
    case 10: // AuthenticationSASL
      msg.name = 'authenticationSASL';
      msg.mechanisms = [];
      do {
        var mechanism = this.parseCString(buffer);

        if (mechanism) {
          msg.mechanisms.push(mechanism);
        }
      } while (mechanism)

      return msg
    case 11: // AuthenticationSASLContinue
      msg.name = 'authenticationSASLContinue';
      msg.data = this.readString(buffer, length - 4);

      return msg
    case 12: // AuthenticationSASLFinal
      msg.name = 'authenticationSASLFinal';
      msg.data = this.readString(buffer, length - 4);

      return msg
  }

  throw new Error('Unknown authenticationOk message type' + util.inspect(msg))
};

Connection.prototype.parseS = function (buffer, length) {
  var msg = new Message('parameterStatus', length);
  msg.parameterName = this.parseCString(buffer);
  msg.parameterValue = this.parseCString(buffer);
  return msg
};

Connection.prototype.parseK = function (buffer, length) {
  var msg = new Message('backendKeyData', length);
  msg.processID = this.parseInt32(buffer);
  msg.secretKey = this.parseInt32(buffer);
  return msg
};

Connection.prototype.parseC = function (buffer, length) {
  var msg = new Message('commandComplete', length);
  msg.text = this.parseCString(buffer);
  return msg
};

Connection.prototype.parseZ = function (buffer, length) {
  var msg = new Message('readyForQuery', length);
  msg.name = 'readyForQuery';
  msg.status = this.readString(buffer, 1);
  return msg
};

var ROW_DESCRIPTION = 'rowDescription';
Connection.prototype.parseT = function (buffer, length) {
  var msg = new Message(ROW_DESCRIPTION, length);
  msg.fieldCount = this.parseInt16(buffer);
  var fields = [];
  for (var i = 0; i < msg.fieldCount; i++) {
    fields.push(this.parseField(buffer));
  }
  msg.fields = fields;
  return msg
};

var Field = function () {
  this.name = null;
  this.tableID = null;
  this.columnID = null;
  this.dataTypeID = null;
  this.dataTypeSize = null;
  this.dataTypeModifier = null;
  this.format = null;
};

var FORMAT_TEXT = 'text';
var FORMAT_BINARY = 'binary';
Connection.prototype.parseField = function (buffer) {
  var field = new Field();
  field.name = this.parseCString(buffer);
  field.tableID = this.parseInt32(buffer);
  field.columnID = this.parseInt16(buffer);
  field.dataTypeID = this.parseInt32(buffer);
  field.dataTypeSize = this.parseInt16(buffer);
  field.dataTypeModifier = this.parseInt32(buffer);
  if (this.parseInt16(buffer) === TEXT_MODE) {
    this._mode = TEXT_MODE;
    field.format = FORMAT_TEXT;
  } else {
    this._mode = BINARY_MODE;
    field.format = FORMAT_BINARY;
  }
  return field
};

var DATA_ROW = 'dataRow';
var DataRowMessage = function (length, fieldCount) {
  this.name = DATA_ROW;
  this.length = length;
  this.fieldCount = fieldCount;
  this.fields = [];
};

// extremely hot-path code
Connection.prototype.parseD = function (buffer, length) {
  var fieldCount = this.parseInt16(buffer);
  var msg = new DataRowMessage(length, fieldCount);
  for (var i = 0; i < fieldCount; i++) {
    msg.fields.push(this._readValue(buffer));
  }
  return msg
};

// extremely hot-path code
Connection.prototype._readValue = function (buffer) {
  var length = this.parseInt32(buffer);
  if (length === -1) return null
  if (this._mode === TEXT_MODE) {
    return this.readString(buffer, length)
  }
  return this.readBytes(buffer, length)
};

// parses error
Connection.prototype.parseE = function (buffer, length) {
  var fields = {};
  var msg, item;
  var input = new Message('error', length);
  var fieldType = this.readString(buffer, 1);
  while (fieldType !== '\0') {
    fields[fieldType] = this.parseCString(buffer);
    fieldType = this.readString(buffer, 1);
  }
  if (input.name === 'error') {
    // the msg is an Error instance
    msg = new Error(fields.M);
    for (item in input) {
      // copy input properties to the error
      if (Object.prototype.hasOwnProperty.call(input, item)) {
        msg[item] = input[item];
      }
    }
  } else {
    // the msg is an object literal
    msg = input;
    msg.message = fields.M;
  }
  msg.severity = fields.S;
  msg.code = fields.C;
  msg.detail = fields.D;
  msg.hint = fields.H;
  msg.position = fields.P;
  msg.internalPosition = fields.p;
  msg.internalQuery = fields.q;
  msg.where = fields.W;
  msg.schema = fields.s;
  msg.table = fields.t;
  msg.column = fields.c;
  msg.dataType = fields.d;
  msg.constraint = fields.n;
  msg.file = fields.F;
  msg.line = fields.L;
  msg.routine = fields.R;
  return msg
};

// same thing, different name
Connection.prototype.parseN = function (buffer, length) {
  var msg = this.parseE(buffer, length);
  msg.name = 'notice';
  return msg
};

Connection.prototype.parseA = function (buffer, length) {
  var msg = new Message('notification', length);
  msg.processId = this.parseInt32(buffer);
  msg.channel = this.parseCString(buffer);
  msg.payload = this.parseCString(buffer);
  return msg
};

Connection.prototype.parseG = function (buffer, length) {
  var msg = new Message('copyInResponse', length);
  return this.parseGH(buffer, msg)
};

Connection.prototype.parseH = function (buffer, length) {
  var msg = new Message('copyOutResponse', length);
  return this.parseGH(buffer, msg)
};

Connection.prototype.parseGH = function (buffer, msg) {
  var isBinary = buffer[this.offset] !== 0;
  this.offset++;
  msg.binary = isBinary;
  var columnCount = this.parseInt16(buffer);
  msg.columnTypes = [];
  for (var i = 0; i < columnCount; i++) {
    msg.columnTypes.push(this.parseInt16(buffer));
  }
  return msg
};

Connection.prototype.parsed = function (buffer, length) {
  var msg = new Message('copyData', length);
  msg.chunk = this.readBytes(buffer, msg.length - 4);
  return msg
};

Connection.prototype.parseInt32 = function (buffer) {
  var value = buffer.readInt32BE(this.offset);
  this.offset += 4;
  return value
};

Connection.prototype.parseInt16 = function (buffer) {
  var value = buffer.readInt16BE(this.offset);
  this.offset += 2;
  return value
};

Connection.prototype.readString = function (buffer, length) {
  return buffer.toString(this.encoding, this.offset, (this.offset += length))
};

Connection.prototype.readBytes = function (buffer, length) {
  return buffer.slice(this.offset, (this.offset += length))
};

Connection.prototype.parseCString = function (buffer) {
  var start = this.offset;
  var end = buffer.indexOf(0, start);
  this.offset = end + 1;
  return buffer.toString(this.encoding, start, end)
};
// end parsing methods
var connection = Connection;

/**
 * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * README.md file in the root directory of this source tree.
 */

var EventEmitter$2 = events.EventEmitter;











var Client = function (config) {
  EventEmitter$2.call(this);

  this.connectionParameters = new connectionParameters(config);
  this.user = this.connectionParameters.user;
  this.database = this.connectionParameters.database;
  this.port = this.connectionParameters.port;
  this.host = this.connectionParameters.host;
  this.password = this.connectionParameters.password;
  this.replication = this.connectionParameters.replication;

  var c = config || {};

  this._Promise = c.Promise || commonjsGlobal.Promise;
  this._types = new typeOverrides(c.types);
  this._ending = false;
  this._connecting = false;
  this._connected = false;
  this._connectionError = false;
  this._queryable = true;

  this.connection = c.connection || new connection({
    stream: c.stream,
    ssl: this.connectionParameters.ssl,
    keepAlive: c.keepAlive || false,
    keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
    encoding: this.connectionParameters.client_encoding || 'utf8'
  });
  this.queryQueue = [];
  this.binary = c.binary || defaults.binary;
  this.processID = null;
  this.secretKey = null;
  this.ssl = this.connectionParameters.ssl || false;
  this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
};

util.inherits(Client, EventEmitter$2);

Client.prototype._errorAllQueries = function (err) {
  const enqueueError = (query) => {
    process.nextTick(() => {
      query.handleError(err, this.connection);
    });
  };

  if (this.activeQuery) {
    enqueueError(this.activeQuery);
    this.activeQuery = null;
  }

  this.queryQueue.forEach(enqueueError);
  this.queryQueue.length = 0;
};

Client.prototype._connect = function (callback) {
  var self = this;
  var con = this.connection;
  if (this._connecting || this._connected) {
    const err = new Error('Client has already been connected. You cannot reuse a client.');
    process.nextTick(() => {
      callback(err);
    });
    return
  }
  this._connecting = true;

  var connectionTimeoutHandle;
  if (this._connectionTimeoutMillis > 0) {
    connectionTimeoutHandle = setTimeout(() => {
      con._ending = true;
      con.stream.destroy(new Error('timeout expired'));
    }, this._connectionTimeoutMillis);
  }

  if (this.host && this.host.indexOf('/') === 0) {
    con.connect(this.host + '/.s.PGSQL.' + this.port);
  } else {
    con.connect(this.port, this.host);
  }

  // once connection is established send startup message
  con.on('connect', function () {
    if (self.ssl) {
      con.requestSsl();
    } else {
      con.startup(self.getStartupConf());
    }
  });

  con.on('sslconnect', function () {
    con.startup(self.getStartupConf());
  });

  function checkPgPass (cb) {
    return function (msg) {
      if (typeof self.password === 'function') {
        self._Promise.resolve()
          .then(() => self.password())
          .then(pass => {
            if (pass !== undefined) {
              if (typeof pass !== 'string') {
                con.emit('error', new TypeError('Password must be a string'));
                return
              }
              self.connectionParameters.password = self.password = pass;
            } else {
              self.connectionParameters.password = self.password = null;
            }
            cb(msg);
          }).catch(err => {
            con.emit('error', err);
          });
      } else if (self.password !== null) {
        cb(msg);
      } else {
        lib(self.connectionParameters, function (pass) {
          if (undefined !== pass) {
            self.connectionParameters.password = self.password = pass;
          }
          cb(msg);
        });
      }
    }
  }

  // password request handling
  con.on('authenticationCleartextPassword', checkPgPass(function () {
    con.password(self.password);
  }));

  // password request handling
  con.on('authenticationMD5Password', checkPgPass(function (msg) {
    con.password(utils.postgresMd5PasswordHash(self.user, self.password, msg.salt));
  }));

  // password request handling (SASL)
  var saslSession;
  con.on('authenticationSASL', checkPgPass(function (msg) {
    saslSession = sasl.startSession(msg.mechanisms);

    con.sendSASLInitialResponseMessage(saslSession.mechanism, saslSession.response);
  }));

  // password request handling (SASL)
  con.on('authenticationSASLContinue', function (msg) {
    sasl.continueSession(saslSession, self.password, msg.data);

    con.sendSCRAMClientFinalMessage(saslSession.response);
  });

  // password request handling (SASL)
  con.on('authenticationSASLFinal', function (msg) {
    sasl.finalizeSession(saslSession, msg.data);

    saslSession = null;
  });

  con.once('backendKeyData', function (msg) {
    self.processID = msg.processID;
    self.secretKey = msg.secretKey;
  });

  const connectingErrorHandler = (err) => {
    if (this._connectionError) {
      return
    }
    this._connectionError = true;
    clearTimeout(connectionTimeoutHandle);
    if (callback) {
      return callback(err)
    }
    this.emit('error', err);
  };

  const connectedErrorHandler = (err) => {
    this._queryable = false;
    this._errorAllQueries(err);
    this.emit('error', err);
  };

  const connectedErrorMessageHandler = (msg) => {
    const activeQuery = this.activeQuery;

    if (!activeQuery) {
      connectedErrorHandler(msg);
      return
    }

    this.activeQuery = null;
    activeQuery.handleError(msg, con);
  };

  con.on('error', connectingErrorHandler);
  con.on('errorMessage', connectingErrorHandler);

  // hook up query handling events to connection
  // after the connection initially becomes ready for queries
  con.once('readyForQuery', function () {
    self._connecting = false;
    self._connected = true;
    self._attachListeners(con);
    con.removeListener('error', connectingErrorHandler);
    con.removeListener('errorMessage', connectingErrorHandler);
    con.on('error', connectedErrorHandler);
    con.on('errorMessage', connectedErrorMessageHandler);
    clearTimeout(connectionTimeoutHandle);

    // process possible callback argument to Client#connect
    if (callback) {
      callback(null, self);
      // remove callback for proper error handling
      // after the connect event
      callback = null;
    }
    self.emit('connect');
  });

  con.on('readyForQuery', function () {
    var activeQuery = self.activeQuery;
    self.activeQuery = null;
    self.readyForQuery = true;
    if (activeQuery) {
      activeQuery.handleReadyForQuery(con);
    }
    self._pulseQueryQueue();
  });

  con.once('end', () => {
    const error = this._ending
      ? new Error('Connection terminated')
      : new Error('Connection terminated unexpectedly');

    this._errorAllQueries(error);

    if (!this._ending) {
      // if the connection is ended without us calling .end()
      // on this client then we have an unexpected disconnection
      // treat this as an error unless we've already emitted an error
      // during connection.
      if (this._connecting && !this._connectionError) {
        if (callback) {
          callback(error);
        } else {
          connectedErrorHandler(error);
        }
      } else if (!this._connectionError) {
        connectedErrorHandler(error);
      }
    }

    process.nextTick(() => {
      this.emit('end');
    });
  });

  con.on('notice', function (msg) {
    self.emit('notice', msg);
  });
};

Client.prototype.connect = function (callback) {
  if (callback) {
    this._connect(callback);
    return
  }

  return new this._Promise((resolve, reject) => {
    this._connect((error) => {
      if (error) {
        reject(error);
      } else {
        resolve();
      }
    });
  })
};

Client.prototype._attachListeners = function (con) {
  const self = this;
  // delegate rowDescription to active query
  con.on('rowDescription', function (msg) {
    self.activeQuery.handleRowDescription(msg);
  });

  // delegate dataRow to active query
  con.on('dataRow', function (msg) {
    self.activeQuery.handleDataRow(msg);
  });

  // delegate portalSuspended to active query
  // eslint-disable-next-line no-unused-vars
  con.on('portalSuspended', function (msg) {
    self.activeQuery.handlePortalSuspended(con);
  });

  // delegate emptyQuery to active query
  // eslint-disable-next-line no-unused-vars
  con.on('emptyQuery', function (msg) {
    self.activeQuery.handleEmptyQuery(con);
  });

  // delegate commandComplete to active query
  con.on('commandComplete', function (msg) {
    self.activeQuery.handleCommandComplete(msg, con);
  });

  // if a prepared statement has a name and properly parses
  // we track that its already been executed so we don't parse
  // it again on the same client
  // eslint-disable-next-line no-unused-vars
  con.on('parseComplete', function (msg) {
    if (self.activeQuery.name) {
      con.parsedStatements[self.activeQuery.name] = self.activeQuery.text;
    }
  });

  // eslint-disable-next-line no-unused-vars
  con.on('copyInResponse', function (msg) {
    self.activeQuery.handleCopyInResponse(self.connection);
  });

  con.on('copyData', function (msg) {
    self.activeQuery.handleCopyData(msg, self.connection);
  });

  con.on('notification', function (msg) {
    self.emit('notification', msg);
  });
};

Client.prototype.getStartupConf = function () {
  var params = this.connectionParameters;

  var data = {
    user: params.user,
    database: params.database
  };

  var appName = params.application_name || params.fallback_application_name;
  if (appName) {
    data.application_name = appName;
  }
  if (params.replication) {
    data.replication = '' + params.replication;
  }
  if (params.statement_timeout) {
    data.statement_timeout = String(parseInt(params.statement_timeout, 10));
  }

  return data
};

Client.prototype.cancel = function (client, query) {
  if (client.activeQuery === query) {
    var con = this.connection;

    if (this.host && this.host.indexOf('/') === 0) {
      con.connect(this.host + '/.s.PGSQL.' + this.port);
    } else {
      con.connect(this.port, this.host);
    }

    // once connection is established send cancel message
    con.on('connect', function () {
      con.cancel(client.processID, client.secretKey);
    });
  } else if (client.queryQueue.indexOf(query) !== -1) {
    client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
  }
};

Client.prototype.setTypeParser = function (oid, format, parseFn) {
  return this._types.setTypeParser(oid, format, parseFn)
};

Client.prototype.getTypeParser = function (oid, format) {
  return this._types.getTypeParser(oid, format)
};

// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
Client.prototype.escapeIdentifier = function (str) {
  return '"' + str.replace(/"/g, '""') + '"'
};

// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
Client.prototype.escapeLiteral = function (str) {
  var hasBackslash = false;
  var escaped = '\'';

  for (var i = 0; i < str.length; i++) {
    var c = str[i];
    if (c === '\'') {
      escaped += c + c;
    } else if (c === '\\') {
      escaped += c + c;
      hasBackslash = true;
    } else {
      escaped += c;
    }
  }

  escaped += '\'';

  if (hasBackslash === true) {
    escaped = ' E' + escaped;
  }

  return escaped
};

Client.prototype._pulseQueryQueue = function () {
  if (this.readyForQuery === true) {
    this.activeQuery = this.queryQueue.shift();
    if (this.activeQuery) {
      this.readyForQuery = false;
      this.hasExecuted = true;

      const queryError = this.activeQuery.submit(this.connection);
      if (queryError) {
        process.nextTick(() => {
          this.activeQuery.handleError(queryError, this.connection);
          this.readyForQuery = true;
          this._pulseQueryQueue();
        });
      }
    } else if (this.hasExecuted) {
      this.activeQuery = null;
      this.emit('drain');
    }
  }
};

Client.prototype.query = function (config, values, callback) {
  // can take in strings, config object or query object
  var query$1;
  var result;
  var readTimeout;
  var readTimeoutTimer;
  var queryCallback;

  if (config === null || config === undefined) {
    throw new TypeError('Client was passed a null or undefined query')
  } else if (typeof config.submit === 'function') {
    readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
    result = query$1 = config;
    if (typeof values === 'function') {
      query$1.callback = query$1.callback || values;
    }
  } else {
    readTimeout = this.connectionParameters.query_timeout;
    query$1 = new query(config, values, callback);
    if (!query$1.callback) {
      result = new this._Promise((resolve, reject) => {
        query$1.callback = (err, res) => err ? reject(err) : resolve(res);
      });
    }
  }

  if (readTimeout) {
    queryCallback = query$1.callback;

    readTimeoutTimer = setTimeout(() => {
      var error = new Error('Query read timeout');

      process.nextTick(() => {
        query$1.handleError(error, this.connection);
      });

      queryCallback(error);

      // we already returned an error,
      // just do nothing if query completes
      query$1.callback = () => {};

      // Remove from queue
      var index = this.queryQueue.indexOf(query$1);
      if (index > -1) {
        this.queryQueue.splice(index, 1);
      }

      this._pulseQueryQueue();
    }, readTimeout);

    query$1.callback = (err, res) => {
      clearTimeout(readTimeoutTimer);
      queryCallback(err, res);
    };
  }

  if (this.binary && !query$1.binary) {
    query$1.binary = true;
  }

  if (query$1._result && !query$1._result._types) {
    query$1._result._types = this._types;
  }

  if (!this._queryable) {
    process.nextTick(() => {
      query$1.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection);
    });
    return result
  }

  if (this._ending) {
    process.nextTick(() => {
      query$1.handleError(new Error('Client was closed and is not queryable'), this.connection);
    });
    return result
  }

  this.queryQueue.push(query$1);
  this._pulseQueryQueue();
  return result
};

Client.prototype.end = function (cb) {
  this._ending = true;

  if (this.activeQuery) {
    // if we have an active query we need to force a disconnect
    // on the socket - otherwise a hung query could block end forever
    this.connection.stream.destroy();
  } else {
    this.connection.end();
  }

  if (cb) {
    this.connection.once('end', cb);
  } else {
    return new this._Promise((resolve) => {
      this.connection.once('end', resolve);
    })
  }
};

// expose a Query constructor
Client.Query = query;

var client = Client;

//Parse method copied from https://github.com/brianc/node-postgres
//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)
//MIT License

//parses a connection string
function parse$4(str) {
  //unix socket
  if (str.charAt(0) === '/') {
    var config = str.split(' ');
    return { host: config[0], database: config[1] }
  }

  // url parse expects spaces encoded as %20
  var result = url.parse(
    / |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str) ? encodeURI(str).replace(/\%25(\d\d)/g, '%$1') : str,
    true
  );
  var config = result.query;
  for (var k in config) {
    if (Array.isArray(config[k])) {
      config[k] = config[k][config[k].length - 1];
    }
  }

  var auth = (result.auth || ':').split(':');
  config.user = auth[0];
  config.password = auth.splice(1).join(':');

  config.port = result.port;
  if (result.protocol == 'socket:') {
    config.host = decodeURI(result.pathname);
    config.database = result.query.db;
    config.client_encoding = result.query.encoding;
    return config
  }
  if (!config.host) {
    // Only set the host if there is no equivalent query param.
    config.host = result.hostname;
  }

  // If the host is missing it might be a URL-encoded path to a socket.
  var pathname = result.pathname;
  if (!config.host && pathname && /^%2f/i.test(pathname)) {
    var pathnameSplit = pathname.split('/');
    config.host = decodeURIComponent(pathnameSplit[0]);
    pathname = pathnameSplit.splice(1).join('/');
  }
  // result.pathname is not always guaranteed to have a '/' prefix (e.g. relative urls)
  // only strip the slash if it is present.
  if (pathname && pathname.charAt(0) === '/') {
    pathname = pathname.slice(1) || null;
  }
  config.database = pathname && decodeURI(pathname);

  if (config.ssl === 'true' || config.ssl === '1') {
    config.ssl = true;
  }

  if (config.ssl === '0') {
    config.ssl = false;
  }

  if (config.sslcert || config.sslkey || config.sslrootcert) {
    config.ssl = {};
  }

  if (config.sslcert) {
    config.ssl.cert = fs.readFileSync(config.sslcert).toString();
  }

  if (config.sslkey) {
    config.ssl.key = fs.readFileSync(config.sslkey).toString();
  }

  if (config.sslrootcert) {
    config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
  }

  return config
}

var pgConnectionString$1 = parse$4;

parse$4.parse = parse$4;

exports.client = client;
exports.pgConnectionString = pgConnectionString$1;
